# csapp_code
学习csapp时敲的代码。

## 12.29日
完成add指令的汇编模拟。
总体的思路是模拟cpu执行汇编代码时寄存器与内存栈中数据的变化。

### cpu
首先用struc结构来模拟cpu，这里我们只模拟cpu的两个功能，一个是寄存机，一个是内存转换（也就是虚拟地址变成物理地址的算法）

首先是寄存器，用unit64_t来模拟64位寄存器，并且用union结构来表示同地址的小寄存器。

然后内存转换的算法就是很简单的一个取模运算。

### 磁盘
在磁盘文件文件中用数组来模拟一组汇编指令集。

### 内存
在内存中我们干了**核心**的事。简单来说我们定义了一个汇编指令结构，其中包含指令类型，第一个操作数，第二个操作数，以及一个说明字符串。

对于指令类型，我们用枚举的方法例举能用到的指令，用来我们后面对应不同的实现函数。

对于两个操作数，也定义了一种结构来表示两种操作数，包括操作数类型，立即数，扩展系数（好像有其他名字，但是就是这个意思吧），第一寄存器指针和第二寄存器指针。其中操作数类型仍然是用枚举的方法，来用于后面解析操作数的地址时所用到的方法。

定义了解析操作数地址的方法，根据操作数类型来返回虚拟地址。

定义了一个函数指针数组，参数是两个虚拟地址。用来模拟治疗真正做的事。

定义函数指针数组初始化函数，让其元素指向对应枚举类型（枚举类型的实质是整数，可以用来代表下标）。

定义循环函数，根据寄存器rip指向的地址来获取指令，根据指令的类型来选择函数。

在dram中用unit8_t数组来模拟内存。模拟内存的读取与写入，在本版本中没有用到缓存技术，但是留有缓存技术的代码空间。

## cmake用法简记

cmake其实就是一种脚本。好处就是对于拥有多个代码块的项目，如果一个一个的用g++敲进去，实在是太慢，用脚本代替就会简单很多。
